# Wiring Guide: Domain Use Cases with Data Repositories

This guide explains how the application layers are wired together.

## Architecture Overview

```
apps/api (main.rs)
    ↓ creates
[Database Pool] → [Repositories (data crate)] → [UseCases (domain crate)]
    ↓ stored in
[AppState]
    ↓ used by
[Route Handlers]
```

## Component Layers

### 1. Domain Layer (`crates/domain`)
- **Repository Traits**: Define interfaces (e.g., `UsersRepository`, `ArticlesRepository`)
- **Use Cases**: Business logic that uses repository traits
- **Entities**: Domain models (`User`, `Article`, `Comment`)

### 2. Data Layer (`crates/data`)
- **Repository Implementations**: `PostgresUsersRepository`, `PostgresArticlesRepository`, `PostgresCommentsRepository`
- **Database Queries**: Generated by clorinde
- **Database Connection**: Uses `deadpool-postgres`

### 3. API Layer (`apps/api`)
- **Main**: Initializes everything and wires dependencies
- **AppState**: Holds shared application state including use cases
- **Routes**: HTTP handlers that use AppState

## Wiring Steps (Already Done)

### Step 1: Export Repositories from Data Crate
File: `crates/data/src/lib.rs`
```rust
pub mod repositories;
pub mod clorinde;

pub use repositories::{
    PostgresArticlesRepository, 
    PostgresCommentsRepository, 
    PostgresUsersRepository
};
```

### Step 2: Add Use Cases to AppState
File: `apps/api/src/state/mod.rs`
```rust
use domain::use_cases::UseCases;
use std::sync::Arc;

#[derive(Clone)]
pub struct AppState {
    // ... existing fields ...
    pub use_cases: Option<Arc<UseCases<
        data::PostgresUsersRepository, 
        data::PostgresArticlesRepository
    >>>,
}
```

### Step 3: Initialize in main.rs
File: `apps/api/src/main.rs`
```rust
use deadpool_postgres::{Config as PoolConfig, ManagerConfig, RecyclingMethod, Runtime};
use tokio_postgres::NoTls;

// Create database pool
let mut pool_config = PoolConfig::new();
pool_config.url = Some(config.database.url.clone());
pool_config.manager = Some(ManagerConfig {
    recycling_method: RecyclingMethod::Fast,
});
pool_config.pool = Some(deadpool_postgres::PoolConfig::new(
    config.database.pool_size
));

let pool = pool_config
    .create_pool(Some(Runtime::Tokio1), NoTls)
    .context("failed to create database pool")?;

// Create repository instances
let users_repo = data::PostgresUsersRepository::new(pool.clone());
let articles_repo = data::PostgresArticlesRepository::new(pool.clone());

// Create use cases with repositories
let use_cases = domain::use_cases::UseCases::new(users_repo, articles_repo);

// Add to AppState
let mut state = AppState::default();
state.use_cases = Some(Arc::new(use_cases));
```

## Using Repositories in Route Handlers

### Example: Access Repository from Use Cases

```rust
use axum::{extract::State, Json};
use domain::Email;

async fn get_user_by_email(
    State(state): State<AppState>,
    email: String,
) -> Result<Json<User>, ApiError> {
    let use_cases = state.use_cases
        .as_ref()
        .ok_or(ApiError::InternalError)?;
    
    // Use the repository through use cases
    let user = use_cases.users_repo
        .get_user_by_email(&email)
        .await?
        .ok_or(ApiError::NotFound)?;
    
    Ok(Json(user))
}
```

### Example: Direct Repository Access (if needed)

If you need direct repository access without going through use cases:

```rust
async fn create_user(
    State(state): State<AppState>,
    Json(new_user): Json<User>,
) -> Result<Json<User>, ApiError> {
    let use_cases = state.use_cases
        .as_ref()
        .ok_or(ApiError::InternalError)?;
    
    let created = use_cases.users_repo
        .create_user(new_user)
        .await?;
    
    Ok(Json(created))
}
```

## Configuration

Database connection configured via:
- Environment variable: `APP__DATABASE__URL=postgresql://user:pass@localhost/dbname`
- Config file: `config/base.toml`

```toml
[database]
url = "postgresql://localhost/realworld"
pool_size = 10
```

## Benefits of This Architecture

1. **Dependency Inversion**: Domain doesn't depend on infrastructure
2. **Testability**: Can swap implementations (e.g., InMemory for tests)
3. **Separation of Concerns**: Each layer has clear responsibilities
4. **Type Safety**: Compile-time guarantees for repository contracts

## Current Status

✅ **Wiring Complete**: Database pool → Repositories → UseCases → AppState
✅ **AppState Simplified**: Removed all in-memory state, now only holds `sessions` and `use_cases`
⚠️ **Migration Needed**: Route handlers still reference old in-memory fields (41 compilation errors)

## Next Steps

See `MIGRATION_GUIDE.md` for detailed instructions on migrating route handlers from in-memory state to repositories.

Key tasks:
1. Migrate route handlers to use `state.use_cases.users_repo` / `articles_repo`
2. Add CommentsRepository to UseCases struct
3. Implement proper JWT authentication to replace in-memory sessions
4. Add integration tests for database operations
